{"version":3,"file":"xterm-addon-search.js","mappings":"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","sources":["webpack://SearchAddon/webpack/universalModuleDefinition","webpack://SearchAddon/./src/SearchAddon.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SearchAddon\"] = factory();\n\telse\n\t\troot[\"SearchAddon\"] = factory();\n})(self, function() {\nreturn ","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, IBufferLine, IDisposable, ITerminalAddon, ISelectionPosition } from 'xterm';\n\nexport interface ISearchOptions {\n  regex?: boolean;\n  wholeWord?: boolean;\n  caseSensitive?: boolean;\n  incremental?: boolean;\n}\n\nexport interface ISearchPosition {\n  startCol: number;\n  startRow: number;\n}\n\nexport interface ISearchResult {\n  term: string;\n  col: number;\n  row: number;\n  size: number;\n}\n\ntype LineCacheEntry = [\n  /**\n   * The string representation of a line (as opposed to the buffer cell representation).\n   */\n  lineAsString: string,\n  /**\n   * The offsets where each line starts when the entry describes a wrapped line.\n   */\n  lineOffsets: number[]\n];\n\nconst NON_WORD_CHARACTERS = ' ~!@#$%^&*()+`-=[]{}|\\\\;:\"\\',./<>?';\nconst LINES_CACHE_TIME_TO_LIVE = 15 * 1000; // 15 secs\n\nexport class SearchAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n\n  /**\n   * translateBufferLineToStringWithWrap is a fairly expensive call.\n   * We memoize the calls into an array that has a time based ttl.\n   * _linesCache is also invalidated when the terminal cursor moves.\n   */\n  private _linesCache: LineCacheEntry[] | undefined;\n  private _linesCacheTimeoutId = 0;\n  private _cursorMoveListener: IDisposable | undefined;\n  private _resizeListener: IDisposable | undefined;\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n  }\n\n  public dispose(): void { }\n\n  /**\n   * Find the next instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @return Whether a result was found.\n   */\n  public findNext(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return false;\n    }\n\n    let startCol = 0;\n    let startRow = 0;\n    let currentSelection: ISelectionPosition | undefined;\n    if (this._terminal.hasSelection()) {\n      const incremental = searchOptions ? searchOptions.incremental : false;\n      // Start from the selection end if there is a selection\n      // For incremental search, use existing row\n      currentSelection = this._terminal.getSelectionPosition()!;\n      startRow = incremental ? currentSelection.startRow : currentSelection.endRow;\n      startCol = incremental ? currentSelection.startColumn : currentSelection.endColumn;\n    }\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    let result = this._findInLine(term, searchPosition, searchOptions);\n\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the bottom and didn't search from the very top wrap back up\n    if (!result && startRow !== 0) {\n      for (let y = 0; y < startRow; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, wrap back and return selection if it exists.\n    if (!result && currentSelection) {\n      searchPosition.startRow = currentSelection.startRow;\n      searchPosition.startCol = 0;\n      result = this._findInLine(term, searchPosition, searchOptions);\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result);\n  }\n\n  /**\n   * Find the previous instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @return Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n\n    if (!term || term.length === 0) {\n      this._terminal.clearSelection();\n      return false;\n    }\n\n    const isReverseSearch = true;\n    let startRow = this._terminal.buffer.active.baseY + this._terminal.rows;\n    let startCol = this._terminal.cols;\n    let result: ISearchResult | undefined;\n    const incremental = searchOptions ? searchOptions.incremental : false;\n    let currentSelection: ISelectionPosition | undefined;\n    if (this._terminal.hasSelection()) {\n      currentSelection = this._terminal.getSelectionPosition()!;\n      // Start from selection start if there is a selection\n      startRow = currentSelection.startRow;\n      startCol = currentSelection.startColumn;\n    }\n\n    this._initLinesCache();\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    if (incremental) {\n      // Try to expand selection to right first.\n      result = this._findInLine(term, searchPosition, searchOptions, false);\n      const isOldResultHighlighted = result && result.row === startRow && result.col === startCol;\n      if (!isOldResultHighlighted) {\n        // If selection was not able to be expanded to the right, then try reverse search\n        if (currentSelection) {\n          searchPosition.startRow = currentSelection.endRow;\n          searchPosition.startCol = currentSelection.endColumn;\n        }\n        result = this._findInLine(term, searchPosition, searchOptions, true);\n      }\n    } else {\n      result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n    }\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      searchPosition.startCol = Math.max(searchPosition.startCol, this._terminal.cols);\n      for (let y = startRow - 1; y >= 0; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the top and didn't search from the very bottom wrap back down\n    if (!result && startRow !== (this._terminal.buffer.active.baseY + this._terminal.rows)) {\n      for (let y = (this._terminal.buffer.active.baseY + this._terminal.rows); y >= startRow; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, return true.\n    if (!result && currentSelection) return true;\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result);\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  private _initLinesCache(): void {\n    const terminal = this._terminal!;\n    if (!this._linesCache) {\n      this._linesCache = new Array(terminal.buffer.active.length);\n      this._cursorMoveListener = terminal.onCursorMove(() => this._destroyLinesCache());\n      this._resizeListener = terminal.onResize(() => this._destroyLinesCache());\n    }\n\n    window.clearTimeout(this._linesCacheTimeoutId);\n    this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), LINES_CACHE_TIME_TO_LIVE);\n  }\n\n  private _destroyLinesCache(): void {\n    this._linesCache = undefined;\n    if (this._cursorMoveListener) {\n      this._cursorMoveListener.dispose();\n      this._cursorMoveListener = undefined;\n    }\n    if (this._resizeListener) {\n      this._resizeListener.dispose();\n      this._resizeListener = undefined;\n    }\n    if (this._linesCacheTimeoutId) {\n      window.clearTimeout(this._linesCacheTimeoutId);\n      this._linesCacheTimeoutId = 0;\n    }\n  }\n\n  /**\n   * A found substring is a whole word if it doesn't have an alphanumeric character directly adjacent to it.\n   * @param searchIndex starting indext of the potential whole word substring\n   * @param line entire string in which the potential whole word was found\n   * @param term the substring that starts at searchIndex\n   */\n  private _isWholeWord(searchIndex: number, line: string, term: string): boolean {\n    return ((searchIndex === 0) || (NON_WORD_CHARACTERS.includes(line[searchIndex - 1]))) &&\n      (((searchIndex + term.length) === line.length) || (NON_WORD_CHARACTERS.includes(line[searchIndex + term.length])));\n  }\n\n  /**\n   * Searches a line for a search term. Takes the provided terminal line and searches the text line, which may contain\n   * subsequent terminal lines if the text is wrapped. If the provided line number is part of a wrapped text line that\n   * started on an earlier line then it is skipped since it will be properly searched when the terminal line that the\n   * text starts on is searched.\n   * @param term The search term.\n   * @param position The position to start the search.\n   * @param searchOptions Search options.\n   * @param isReverseSearch Whether the search should start from the right side of the terminal and search to the left.\n   * @return The search result if it was found.\n   */\n  protected _findInLine(term: string, searchPosition: ISearchPosition, searchOptions: ISearchOptions = {}, isReverseSearch: boolean = false): ISearchResult | undefined {\n    const terminal = this._terminal!;\n    const row = searchPosition.startRow;\n    const col = searchPosition.startCol;\n\n    // Ignore wrapped lines, only consider on unwrapped line (first row of command string).\n    const firstLine = terminal.buffer.active.getLine(row);\n    if (firstLine?.isWrapped) {\n      if (isReverseSearch) {\n        searchPosition.startCol += terminal.cols;\n        return;\n      }\n\n      // This will iterate until we find the line start.\n      // When we find it, we will search using the calculated start column.\n      searchPosition.startRow--;\n      searchPosition.startCol += terminal.cols;\n      return this._findInLine(term, searchPosition, searchOptions);\n    }\n    let cache = this._linesCache?.[row];\n    if (!cache) {\n      cache = this._translateBufferLineToStringWithWrap(row, true);\n      if (this._linesCache) {\n        this._linesCache[row] = cache;\n      }\n    }\n    const [stringLine, offsets] = cache;\n\n    const offset = this._bufferColsToStringOffset(row, col);\n    const searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();\n    const searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();\n\n    let resultIndex = -1;\n    if (searchOptions.regex) {\n      const searchRegex = RegExp(searchTerm, 'g');\n      let foundTerm: RegExpExecArray | null;\n      if (isReverseSearch) {\n        // This loop will get the resultIndex of the _last_ regex match in the range 0..offset\n        while (foundTerm = searchRegex.exec(searchStringLine.slice(0, offset))) {\n          resultIndex = searchRegex.lastIndex - foundTerm[0].length;\n          term = foundTerm[0];\n          searchRegex.lastIndex -= (term.length - 1);\n        }\n      } else {\n        foundTerm = searchRegex.exec(searchStringLine.slice(offset));\n        if (foundTerm && foundTerm[0].length > 0) {\n          resultIndex = offset + (searchRegex.lastIndex - foundTerm[0].length);\n          term = foundTerm[0];\n        }\n      }\n    } else {\n      if (isReverseSearch) {\n        if (offset - searchTerm.length >= 0) {\n          resultIndex = searchStringLine.lastIndexOf(searchTerm, offset - searchTerm.length);\n        }\n      } else {\n        resultIndex = searchStringLine.indexOf(searchTerm, offset);\n      }\n    }\n\n    if (resultIndex >= 0) {\n      if (searchOptions.wholeWord && !this._isWholeWord(resultIndex, searchStringLine, term)) {\n        return;\n      }\n\n      // Adjust the row number and search index if needed since a \"line\" of text can span multiple rows\n      let startRowOffset = 0;\n      while (startRowOffset < offsets.length - 1 && resultIndex >= offsets[startRowOffset + 1]) {\n        startRowOffset++;\n      }\n      let endRowOffset = startRowOffset;\n      while (endRowOffset < offsets.length - 1 && resultIndex + term.length >= offsets[endRowOffset + 1]) {\n        endRowOffset++;\n      }\n      const startColOffset = resultIndex - offsets[startRowOffset];\n      const endColOffset = resultIndex + term.length - offsets[endRowOffset];\n      const startColIndex = this._stringLengthToBufferSize(row + startRowOffset, startColOffset);\n      const endColIndex = this._stringLengthToBufferSize(row + endRowOffset, endColOffset);\n      const size = endColIndex - startColIndex + terminal.cols * (endRowOffset - startRowOffset);\n\n      return {\n        term,\n        col: startColIndex,\n        row: row + startRowOffset,\n        size\n      };\n    }\n  }\n\n  private _stringLengthToBufferSize(row: number, offset: number): number {\n    const line = this._terminal!.buffer.active.getLine(row);\n    if (!line) {\n      return 0;\n    }\n    for (let i = 0; i < offset; i++) {\n      const cell = line.getCell(i);\n      if (!cell) {\n        break;\n      }\n      // Adjust the searchIndex to normalize emoji into single chars\n      const char = cell.getChars();\n      if (char.length > 1) {\n        offset -= char.length - 1;\n      }\n      // Adjust the searchIndex for empty characters following wide unicode\n      // chars (eg. CJK)\n      const nextCell = line.getCell(i + 1);\n      if (nextCell && nextCell.getWidth() === 0) {\n        offset++;\n      }\n    }\n    return offset;\n  }\n\n  private _bufferColsToStringOffset(startRow: number, cols: number): number {\n    const terminal = this._terminal!;\n    let lineIndex = startRow;\n    let offset = 0;\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (cols > 0 && line) {\n      for (let i = 0; i < cols && i < terminal.cols; i++) {\n        const cell = line.getCell(i);\n        if (!cell) {\n          break;\n        }\n        if (cell.getWidth()) {\n          offset += cell.getChars().length;\n        }\n      }\n      lineIndex++;\n      line = terminal.buffer.active.getLine(lineIndex);\n      if (line && !line.isWrapped) {\n        break;\n      }\n      cols -= terminal.cols;\n    }\n    return offset;\n  }\n\n  /**\n   * Translates a buffer line to a string, including subsequent lines if they are wraps.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param line The line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   */\n  private _translateBufferLineToStringWithWrap(lineIndex: number, trimRight: boolean): LineCacheEntry {\n    const terminal = this._terminal!;\n    const strings = [];\n    const lineOffsets = [0];\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (line) {\n      const nextLine = terminal.buffer.active.getLine(lineIndex + 1);\n      const lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n      let string = line.translateToString(!lineWrapsToNext && trimRight);\n      if (lineWrapsToNext && nextLine) {\n        const lastCell = line.getCell(line.length - 1);\n        const lastCellIsNull = lastCell && lastCell.getCode() === 0 && lastCell.getWidth() === 1;\n        // a wide character wrapped to the next line\n        if (lastCellIsNull && nextLine.getCell(0)?.getWidth() === 2) {\n          string = string.slice(0, -1);\n        }\n      }\n      strings.push(string);\n      if (lineWrapsToNext) {\n        lineOffsets.push(lineOffsets[lineOffsets.length - 1] + string.length);\n      } else {\n        break;\n      }\n      lineIndex++;\n      line = nextLine;\n    }\n    return [strings.join(''), lineOffsets];\n  }\n\n  /**\n   * Selects and scrolls to a result.\n   * @param result The result to select.\n   * @return Whethera result was selected.\n   */\n  private _selectResult(result: ISearchResult | undefined): boolean {\n    const terminal = this._terminal!;\n    if (!result) {\n      terminal.clearSelection();\n      return false;\n    }\n    terminal.select(result.col, result.row, result.size);\n    // If it is not in the viewport then we scroll else it just gets selected\n    if (result.row >= (terminal.buffer.active.viewportY + terminal.rows) || result.row < terminal.buffer.active.viewportY) {\n      let scroll = result.row - terminal.buffer.active.viewportY;\n      scroll -= Math.floor(terminal.rows / 2);\n      terminal.scrollLines(scroll);\n    }\n    return true;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","NON_WORD_CHARACTERS","_linesCacheTimeoutId","activate","terminal","this","_terminal","dispose","findNext","term","searchOptions","Error","length","clearSelection","currentSelection","startCol","startRow","hasSelection","incremental","getSelectionPosition","endRow","startColumn","endColumn","_initLinesCache","searchPosition","result","_findInLine","y","buffer","active","baseY","rows","_selectResult","findPrevious","isReverseSearch","cols","row","col","Math","max","_linesCache","Array","_cursorMoveListener","onCursorMove","_destroyLinesCache","_resizeListener","onResize","window","clearTimeout","setTimeout","undefined","_isWholeWord","searchIndex","line","includes","firstLine","getLine","isWrapped","cache","_translateBufferLineToStringWithWrap","stringLine","offsets","offset","_bufferColsToStringOffset","searchTerm","caseSensitive","toLowerCase","searchStringLine","resultIndex","regex","searchRegex","RegExp","foundTerm","exec","slice","lastIndex","lastIndexOf","indexOf","wholeWord","startRowOffset","endRowOffset","startColOffset","endColOffset","startColIndex","_stringLengthToBufferSize","size","i","cell","getCell","char","getChars","nextCell","getWidth","lineIndex","trimRight","strings","lineOffsets","nextLine","lineWrapsToNext","string","translateToString","lastCell","getCode","push","join","select","viewportY","floor","scrollLines","SearchAddon"],"sourceRoot":""}