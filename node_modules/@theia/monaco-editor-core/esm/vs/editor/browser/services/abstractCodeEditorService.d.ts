import { Emitter, Event } from '../../../base/common/event';
import { IDisposable, Disposable } from '../../../base/common/lifecycle';
import { URI } from '../../../base/common/uri';
import { ICodeEditor, IDiffEditor } from '../editorBrowser';
import { ICodeEditorService } from './codeEditorService';
import { IDecorationRenderOptions } from '../../common/editorCommon';
import { IModelDecorationOptions, IModelDecorationOverviewRulerOptions, InjectedTextOptions, ITextModel, TrackedRangeStickiness } from '../../common/model';
import { IResourceEditorInput } from '../../../platform/editor/common/editor';
import { IThemeService } from '../../../platform/theme/common/themeService';
export declare abstract class AbstractCodeEditorService extends Disposable implements ICodeEditorService {
    private readonly _themeService;
    readonly _serviceBrand: undefined;
    private readonly _onCodeEditorAdd;
    readonly onCodeEditorAdd: Event<ICodeEditor>;
    private readonly _onCodeEditorRemove;
    readonly onCodeEditorRemove: Event<ICodeEditor>;
    private readonly _onDiffEditorAdd;
    readonly onDiffEditorAdd: Event<IDiffEditor>;
    private readonly _onDiffEditorRemove;
    readonly onDiffEditorRemove: Event<IDiffEditor>;
    private readonly _onDidChangeTransientModelProperty;
    readonly onDidChangeTransientModelProperty: Event<ITextModel>;
    protected readonly _onDecorationTypeRegistered: Emitter<string>;
    onDecorationTypeRegistered: Event<string>;
    private readonly _codeEditors;
    private readonly _diffEditors;
    protected _globalStyleSheet: GlobalStyleSheet | null;
    private readonly _decorationOptionProviders;
    private readonly _editorStyleSheets;
    constructor(_themeService: IThemeService);
    addCodeEditor(editor: ICodeEditor): void;
    removeCodeEditor(editor: ICodeEditor): void;
    listCodeEditors(): ICodeEditor[];
    addDiffEditor(editor: IDiffEditor): void;
    removeDiffEditor(editor: IDiffEditor): void;
    listDiffEditors(): IDiffEditor[];
    getFocusedCodeEditor(): ICodeEditor | null;
    private _getOrCreateGlobalStyleSheet;
    protected _createGlobalStyleSheet(): GlobalStyleSheet;
    private _getOrCreateStyleSheet;
    _removeEditorStyleSheets(editorId: string): void;
    registerDecorationType(description: string, key: string, options: IDecorationRenderOptions, parentTypeKey?: string, editor?: ICodeEditor): void;
    removeDecorationType(key: string): void;
    resolveDecorationOptions(decorationTypeKey: string, writable: boolean): IModelDecorationOptions;
    resolveDecorationCSSRules(decorationTypeKey: string): CSSRuleList | null;
    private readonly _transientWatchers;
    private readonly _modelProperties;
    setModelProperty(resource: URI, key: string, value: any): void;
    getModelProperty(resource: URI, key: string): any;
    setTransientModelProperty(model: ITextModel, key: string, value: any): void;
    getTransientModelProperty(model: ITextModel, key: string): any;
    getTransientModelProperties(model: ITextModel): [string, any][] | undefined;
    _removeWatcher(w: ModelTransientSettingWatcher): void;
    abstract getActiveCodeEditor(): ICodeEditor | null;
    abstract openCodeEditor(input: IResourceEditorInput, source: ICodeEditor | null, sideBySide?: boolean): Promise<ICodeEditor | null>;
}
export declare class ModelTransientSettingWatcher {
    readonly uri: string;
    private readonly _values;
    constructor(uri: string, model: ITextModel, owner: AbstractCodeEditorService);
    set(key: string, value: any): void;
    get(key: string): any;
    keys(): string[];
}
export declare class RefCountedStyleSheet {
    private readonly _parent;
    private readonly _editorId;
    private readonly _styleSheet;
    private _refCount;
    get sheet(): CSSStyleSheet;
    constructor(parent: AbstractCodeEditorService, editorId: string, styleSheet: HTMLStyleElement);
    ref(): void;
    unref(): void;
    insertRule(rule: string, index?: number): void;
    removeRulesContainingSelector(ruleName: string): void;
}
export declare class GlobalStyleSheet {
    private readonly _styleSheet;
    get sheet(): CSSStyleSheet;
    constructor(styleSheet: HTMLStyleElement);
    ref(): void;
    unref(): void;
    insertRule(rule: string, index?: number): void;
    removeRulesContainingSelector(ruleName: string): void;
}
interface IModelDecorationOptionsProvider extends IDisposable {
    refCount: number;
    getOptions(codeEditorService: AbstractCodeEditorService, writable: boolean): IModelDecorationOptions;
    resolveDecorationCSSRules(): CSSRuleList;
}
export declare class DecorationSubTypeOptionsProvider implements IModelDecorationOptionsProvider {
    private readonly _styleSheet;
    refCount: number;
    private readonly _parentTypeKey;
    private _beforeContentRules;
    private _afterContentRules;
    constructor(themeService: IThemeService, styleSheet: GlobalStyleSheet | RefCountedStyleSheet, providerArgs: ProviderArguments);
    getOptions(codeEditorService: AbstractCodeEditorService, writable: boolean): IModelDecorationOptions;
    resolveDecorationCSSRules(): CSSRuleList;
    dispose(): void;
}
interface ProviderArguments {
    styleSheet: GlobalStyleSheet | RefCountedStyleSheet;
    key: string;
    parentTypeKey?: string;
    options: IDecorationRenderOptions;
}
export declare class DecorationTypeOptionsProvider implements IModelDecorationOptionsProvider {
    private readonly _disposables;
    private readonly _styleSheet;
    refCount: number;
    description: string;
    className: string | undefined;
    inlineClassName: string | undefined;
    inlineClassNameAffectsLetterSpacing: boolean | undefined;
    beforeContentClassName: string | undefined;
    afterContentClassName: string | undefined;
    glyphMarginClassName: string | undefined;
    isWholeLine: boolean;
    overviewRuler: IModelDecorationOverviewRulerOptions | undefined;
    stickiness: TrackedRangeStickiness | undefined;
    beforeInjectedText: InjectedTextOptions | undefined;
    afterInjectedText: InjectedTextOptions | undefined;
    constructor(description: string, themeService: IThemeService, styleSheet: GlobalStyleSheet | RefCountedStyleSheet, providerArgs: ProviderArguments);
    getOptions(codeEditorService: AbstractCodeEditorService, writable: boolean): IModelDecorationOptions;
    resolveDecorationCSSRules(): CSSRuleList;
    dispose(): void;
}
export declare const _CSS_MAP: {
    [prop: string]: string;
};
export {};
//# sourceMappingURL=abstractCodeEditorService.d.ts.map