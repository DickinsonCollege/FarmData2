import { CancellationToken } from '../../../../base/common/cancellation';
import { DisposableStore } from '../../../../base/common/lifecycle';
import { ITextModel } from '../../../common/model';
import { FoldingRange, FoldingRangeProvider } from '../../../common/languages';
import { RangeProvider } from './folding';
import { FoldingRegions } from './foldingRanges';
export interface IFoldingRangeData extends FoldingRange {
    rank: number;
}
export declare const ID_SYNTAX_PROVIDER = "syntax";
export declare class SyntaxRangeProvider implements RangeProvider {
    private readonly editorModel;
    private providers;
    private limit;
    readonly id = "syntax";
    readonly disposables: DisposableStore | undefined;
    constructor(editorModel: ITextModel, providers: FoldingRangeProvider[], handleFoldingRangesChange: () => void, limit: number);
    compute(cancellationToken: CancellationToken, notifyTooManyRegions?: (maxRegions: number) => void): Promise<FoldingRegions | null>;
    dispose(): void;
}
export declare class RangesCollector {
    private readonly _notifyTooManyRegions?;
    private readonly _startIndexes;
    private readonly _endIndexes;
    private readonly _nestingLevels;
    private readonly _nestingLevelCounts;
    private readonly _types;
    private _length;
    private readonly _foldingRangesLimit;
    constructor(foldingRangesLimit: number, _notifyTooManyRegions?: ((maxRegions: number) => void) | undefined);
    add(startLineNumber: number, endLineNumber: number, type: string | undefined, nestingLevel: number): void;
    toIndentRanges(): FoldingRegions;
}
export declare function sanitizeRanges(rangeData: IFoldingRangeData[], limit: number, notifyTooManyRegions?: (maxRegions: number) => void): FoldingRegions;
//# sourceMappingURL=syntaxRangeProvider.d.ts.map