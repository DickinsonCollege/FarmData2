import { CancelablePromise } from '../../../../base/common/async';
import { CancellationToken } from '../../../../base/common/cancellation';
import { Emitter } from '../../../../base/common/event';
import { Disposable, IDisposable, MutableDisposable } from '../../../../base/common/lifecycle';
import { IActiveCodeEditor } from '../../../browser/editorBrowser';
import { Position } from '../../../common/core/position';
import { Range } from '../../../common/core/range';
import { ITextModel } from '../../../common/model';
import { InlineCompletion, InlineCompletionContext, InlineCompletions, InlineCompletionsProvider, InlineCompletionTriggerKind } from '../../../common/languages';
import { BaseGhostTextWidgetModel, GhostText, GhostTextWidgetModel } from './ghostText';
import { ICommandService } from '../../../../platform/commands/common/commands';
import { SharedInlineCompletionCache } from './ghostTextModel';
import { NormalizedInlineCompletion } from './inlineCompletionToGhostText';
import { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry';
import { LanguageFeatureRegistry } from '../../../common/languageFeatureRegistry';
import { ILanguageFeaturesService } from '../../../common/services/languageFeatures';
import { IFeatureDebounceInformation, ILanguageFeatureDebounceService } from '../../../common/services/languageFeatureDebounce';
export declare class InlineCompletionsModel extends Disposable implements GhostTextWidgetModel {
    private readonly editor;
    private readonly cache;
    private readonly commandService;
    private readonly languageConfigurationService;
    private readonly languageFeaturesService;
    private readonly debounceService;
    protected readonly onDidChangeEmitter: Emitter<void>;
    readonly onDidChange: import("../../../../base/common/event").Event<void>;
    readonly completionSession: MutableDisposable<InlineCompletionsSession>;
    private active;
    private disposed;
    private readonly debounceValue;
    constructor(editor: IActiveCodeEditor, cache: SharedInlineCompletionCache, commandService: ICommandService, languageConfigurationService: ILanguageConfigurationService, languageFeaturesService: ILanguageFeaturesService, debounceService: ILanguageFeatureDebounceService);
    private handleUserInput;
    private get session();
    get ghostText(): GhostText | undefined;
    get minReservedLineCount(): number;
    get expanded(): boolean;
    setExpanded(expanded: boolean): void;
    setActive(active: boolean): void;
    private startSessionIfTriggered;
    trigger(triggerKind: InlineCompletionTriggerKind): void;
    hide(): void;
    commitCurrentSuggestion(): void;
    showNext(): void;
    showPrevious(): void;
    hasMultipleInlineCompletions(): Promise<boolean>;
}
export declare class InlineCompletionsSession extends BaseGhostTextWidgetModel {
    private readonly triggerPosition;
    private readonly shouldUpdate;
    private readonly commandService;
    private readonly cache;
    private initialTriggerKind;
    private readonly languageConfigurationService;
    private readonly registry;
    private readonly debounce;
    readonly minReservedLineCount = 0;
    private readonly updateOperation;
    private readonly updateSoon;
    constructor(editor: IActiveCodeEditor, triggerPosition: Position, shouldUpdate: () => boolean, commandService: ICommandService, cache: SharedInlineCompletionCache, initialTriggerKind: InlineCompletionTriggerKind, languageConfigurationService: ILanguageConfigurationService, registry: LanguageFeatureRegistry<InlineCompletionsProvider>, debounce: IFeatureDebounceInformation);
    private currentlySelectedCompletionId;
    private fixAndGetIndexOfCurrentSelection;
    private get currentCachedCompletion();
    showNextInlineCompletion(): Promise<void>;
    showPreviousInlineCompletion(): Promise<void>;
    ensureUpdateWithExplicitContext(): Promise<void>;
    hasMultipleInlineCompletions(): Promise<boolean>;
    get ghostText(): GhostText | undefined;
    get currentCompletion(): TrackedInlineCompletion | undefined;
    get isValid(): boolean;
    scheduleAutomaticUpdate(): void;
    private update;
    takeOwnership(disposable: IDisposable): void;
    commitCurrentCompletion(): void;
    commit(completion: TrackedInlineCompletion): void;
}
export declare class UpdateOperation implements IDisposable {
    readonly promise: CancelablePromise<void>;
    readonly triggerKind: InlineCompletionTriggerKind;
    constructor(promise: CancelablePromise<void>, triggerKind: InlineCompletionTriggerKind);
    dispose(): void;
}
/**
 * The cache keeps itself in sync with the editor.
 * It also owns the completions result and disposes it when the cache is diposed.
*/
export declare class SynchronizedInlineCompletionsCache extends Disposable {
    readonly triggerKind: InlineCompletionTriggerKind;
    readonly completions: readonly CachedInlineCompletion[];
    constructor(editor: IActiveCodeEditor, completionsSource: TrackedInlineCompletions, onChange: () => void, triggerKind: InlineCompletionTriggerKind);
}
declare class CachedInlineCompletion {
    readonly inlineCompletion: TrackedInlineCompletion;
    readonly decorationId: string;
    readonly semanticId: string;
    /**
     * The range, synchronized with text model changes.
    */
    synchronizedRange: Range;
    constructor(inlineCompletion: TrackedInlineCompletion, decorationId: string);
    toLiveInlineCompletion(): TrackedInlineCompletion | undefined;
}
/**
 * A normalized inline completion that tracks which inline completion it has been constructed from.
*/
export interface TrackedInlineCompletion extends NormalizedInlineCompletion {
    sourceProvider: InlineCompletionsProvider;
    /**
     * A reference to the original inline completion this inline completion has been constructed from.
     * Used for event data to ensure referential equality.
    */
    sourceInlineCompletion: InlineCompletion;
    /**
     * A reference to the original inline completion list this inline completion has been constructed from.
     * Used for event data to ensure referential equality.
    */
    sourceInlineCompletions: InlineCompletions;
}
/**
 * Contains no duplicated items.
*/
export interface TrackedInlineCompletions extends InlineCompletions<TrackedInlineCompletion> {
    dispose(): void;
}
export declare function provideInlineCompletions(registry: LanguageFeatureRegistry<InlineCompletionsProvider>, position: Position, model: ITextModel, context: InlineCompletionContext, token?: CancellationToken, languageConfigurationService?: ILanguageConfigurationService): Promise<TrackedInlineCompletions>;
/**
 * Shrinks the range if the text has a suffix/prefix that agrees with the text buffer.
 * E.g. text buffer: `ab[cdef]ghi`, [...] is the replace range, `cxyzf` is the new text.
 * Then the minimized inline completion has range `abc[de]fghi` and text `xyz`.
 */
export declare function minimizeInlineCompletion(model: ITextModel, inlineCompletion: NormalizedInlineCompletion): NormalizedInlineCompletion;
export declare function minimizeInlineCompletion(model: ITextModel, inlineCompletion: NormalizedInlineCompletion | undefined): NormalizedInlineCompletion | undefined;
export {};
//# sourceMappingURL=inlineCompletionsModel.d.ts.map