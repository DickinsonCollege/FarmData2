import { IMarkdownString } from '../../../../base/common/htmlContent';
import { MarkdownRenderOptions, MarkedOptions } from '../../../../base/browser/markdownRenderer';
import { IOpenerService } from '../../../../platform/opener/common/opener';
import { ILanguageService } from '../../../common/languages/language';
import { ICodeEditor } from '../../../browser/editorBrowser';
import { IDisposable, DisposableStore } from '../../../../base/common/lifecycle';
export interface IMarkdownRenderResult extends IDisposable {
    element: HTMLElement;
}
export interface IMarkdownRendererOptions {
    editor?: ICodeEditor;
    codeBlockFontFamily?: string;
}
/**
 * Markdown renderer that can render codeblocks with the editor mechanics. This
 * renderer should always be preferred.
 */
export declare class MarkdownRenderer {
    private readonly _options;
    private readonly _languageService;
    private readonly _openerService;
    private static _ttpTokenizer;
    private readonly _onDidRenderAsync;
    readonly onDidRenderAsync: import("../../../../base/common/event").Event<void>;
    constructor(_options: IMarkdownRendererOptions, _languageService: ILanguageService, _openerService: IOpenerService);
    dispose(): void;
    render(markdown: IMarkdownString | undefined, options?: MarkdownRenderOptions, markedOptions?: MarkedOptions): IMarkdownRenderResult;
    protected _getRenderOptions(markdown: IMarkdownString, disposeables: DisposableStore): MarkdownRenderOptions;
}
//# sourceMappingURL=markdownRenderer.d.ts.map