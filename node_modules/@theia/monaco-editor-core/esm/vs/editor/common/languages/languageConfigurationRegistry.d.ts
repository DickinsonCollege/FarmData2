import { Event } from '../../../base/common/event';
import { Disposable, IDisposable } from '../../../base/common/lifecycle';
import { LineTokens } from '../tokens/lineTokens';
import { Range } from '../core/range';
import { ITextModel } from '../model';
import { EnterAction, FoldingRules, IAutoClosingPair, IndentAction, IndentationRule, LanguageConfiguration, CompleteEnterAction, AutoClosingPairs, CharacterPair } from './languageConfiguration';
import { CharacterPairSupport } from './supports/characterPair';
import { BracketElectricCharacterSupport } from './supports/electricCharacter';
import { IndentRulesSupport } from './supports/indentRules';
import { RichEditBrackets } from './supports/richEditBrackets';
import { EditorAutoIndentStrategy } from '../config/editorOptions';
import { IConfigurationService } from '../../../platform/configuration/common/configuration';
import { ILanguageService } from './language';
/**
 * Interface used to support insertion of mode specific comments.
 */
export interface ICommentsConfiguration {
    lineCommentToken?: string;
    blockCommentStartToken?: string;
    blockCommentEndToken?: string;
}
export interface IVirtualModel {
    getLineTokens(lineNumber: number): LineTokens;
    getLanguageId(): string;
    getLanguageIdAtPosition(lineNumber: number, column: number): string;
    getLineContent(lineNumber: number): string;
}
export interface IIndentConverter {
    shiftIndent(indentation: string): string;
    unshiftIndent(indentation: string): string;
    normalizeIndentation?(indentation: string): string;
}
export interface ILanguageConfigurationService {
    readonly _serviceBrand: undefined;
    onDidChange: Event<LanguageConfigurationServiceChangeEvent>;
    getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration;
}
export declare class LanguageConfigurationServiceChangeEvent {
    readonly languageId: string | undefined;
    constructor(languageId: string | undefined);
    affects(languageId: string): boolean;
}
export declare const ILanguageConfigurationService: import("../../../platform/instantiation/common/instantiation").ServiceIdentifier<ILanguageConfigurationService>;
export declare class LanguageConfigurationService extends Disposable implements ILanguageConfigurationService {
    private readonly configurationService;
    private readonly languageService;
    _serviceBrand: undefined;
    private readonly onDidChangeEmitter;
    readonly onDidChange: Event<LanguageConfigurationServiceChangeEvent>;
    private readonly configurations;
    constructor(configurationService: IConfigurationService, languageService: ILanguageService);
    getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration;
}
export declare class LanguageConfigurationChangeEvent {
    readonly languageId: string;
    constructor(languageId: string);
}
export declare class LanguageConfigurationRegistryImpl {
    private readonly _entries;
    private readonly _onDidChange;
    readonly onDidChange: Event<LanguageConfigurationChangeEvent>;
    /**
     * @param priority Use a higher number for higher priority
     */
    register(languageId: string, configuration: LanguageConfiguration, priority?: number): IDisposable;
    getLanguageConfiguration(languageId: string): ResolvedLanguageConfiguration | null;
    getComments(languageId: string): ICommentsConfiguration | null;
    getIndentRulesSupport(languageId: string): IndentRulesSupport | null;
    /**
     * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.
     * Result:
     * -1: run into the boundary of embedded languages
     * 0: every line above are invalid
     * else: nearest preceding line of the same language
     */
    private getPrecedingValidLine;
    /**
     * Get inherited indentation from above lines.
     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
     * 3. If this line doesn't match any indent rules
     *   a. check whether the line above it matches indentNextLinePattern
     *   b. If not, the indent level of this line is the result
     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
     *
     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
     */
    getInheritIndentForLine(autoIndent: EditorAutoIndentStrategy, model: IVirtualModel, lineNumber: number, honorIntentialIndent?: boolean): {
        indentation: string;
        action: IndentAction | null;
        line?: number;
    } | null;
    getGoodIndentForLine(autoIndent: EditorAutoIndentStrategy, virtualModel: IVirtualModel, languageId: string, lineNumber: number, indentConverter: IIndentConverter): string | null;
    getIndentForEnter(autoIndent: EditorAutoIndentStrategy, model: ITextModel, range: Range, indentConverter: IIndentConverter): {
        beforeEnter: string;
        afterEnter: string;
    } | null;
    /**
     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
     */
    getIndentActionForType(autoIndent: EditorAutoIndentStrategy, model: ITextModel, range: Range, ch: string, indentConverter: IIndentConverter): string | null;
    getIndentMetadata(model: ITextModel, lineNumber: number): number | null;
    getEnterAction(autoIndent: EditorAutoIndentStrategy, model: ITextModel, range: Range): CompleteEnterAction | null;
    getIndentationAtPosition(model: ITextModel, lineNumber: number, column: number): string;
    private getScopedLineTokens;
    getBracketsSupport(languageId: string): RichEditBrackets | null;
    getColorizedBracketPairs(languageId: string): readonly CharacterPair[];
}
/**
 * @deprecated Use ILanguageConfigurationService instead.
*/
export declare const LanguageConfigurationRegistry: LanguageConfigurationRegistryImpl;
/**
 * Immutable.
*/
export declare class ResolvedLanguageConfiguration {
    readonly languageId: string;
    readonly underlyingConfig: LanguageConfiguration;
    private _brackets;
    private _electricCharacter;
    private readonly _onEnterSupport;
    readonly comments: ICommentsConfiguration | null;
    readonly characterPair: CharacterPairSupport;
    readonly wordDefinition: RegExp;
    readonly indentRulesSupport: IndentRulesSupport | null;
    readonly indentationRules: IndentationRule | undefined;
    readonly foldingRules: FoldingRules;
    constructor(languageId: string, underlyingConfig: LanguageConfiguration);
    getWordDefinition(): RegExp;
    get brackets(): RichEditBrackets | null;
    get electricCharacter(): BracketElectricCharacterSupport | null;
    onEnter(autoIndent: EditorAutoIndentStrategy, previousLineText: string, beforeEnterText: string, afterEnterText: string): EnterAction | null;
    getAutoClosingPairs(): AutoClosingPairs;
    getAutoCloseBeforeSet(): string;
    getSurroundingPairs(): IAutoClosingPair[];
    private static _handleComments;
}
//# sourceMappingURL=languageConfigurationRegistry.d.ts.map