export declare namespace Iterable {
    function is<T = any>(thing: any): thing is IterableIterator<T>;
    function empty<T = any>(): Iterable<T>;
    function single<T>(element: T): Iterable<T>;
    function from<T>(iterable: Iterable<T> | undefined | null): Iterable<T>;
    function isEmpty<T>(iterable: Iterable<T> | undefined | null): boolean;
    function first<T>(iterable: Iterable<T>): T | undefined;
    function some<T>(iterable: Iterable<T>, predicate: (t: T) => unknown): boolean;
    function find<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): T | undefined;
    function find<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): T | undefined;
    function filter<T, R extends T>(iterable: Iterable<T>, predicate: (t: T) => t is R): Iterable<R>;
    function filter<T>(iterable: Iterable<T>, predicate: (t: T) => boolean): Iterable<T>;
    function map<T, R>(iterable: Iterable<T>, fn: (t: T, index: number) => R): Iterable<R>;
    function concat<T>(...iterables: Iterable<T>[]): Iterable<T>;
    function concatNested<T>(iterables: Iterable<Iterable<T>>): Iterable<T>;
    function reduce<T, R>(iterable: Iterable<T>, reducer: (previousValue: R, currentValue: T) => R, initialValue: R): R;
    /**
     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.
     */
    function slice<T>(arr: ReadonlyArray<T>, from: number, to?: number): Iterable<T>;
    /**
     * Consumes `atMost` elements from iterable and returns the consumed elements,
     * and an iterable for the rest of the elements.
     */
    function consume<T>(iterable: Iterable<T>, atMost?: number): [T[], Iterable<T>];
    /**
     * Returns whether the iterables are the same length and all items are
     * equal using the comparator function.
     */
    function equals<T>(a: Iterable<T>, b: Iterable<T>, comparator?: (at: T, bt: T) => boolean): boolean;
}
//# sourceMappingURL=iterator.d.ts.map