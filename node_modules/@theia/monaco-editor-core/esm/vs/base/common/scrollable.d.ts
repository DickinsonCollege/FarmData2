import { Event } from './event';
import { Disposable, IDisposable } from './lifecycle';
export declare const enum ScrollbarVisibility {
    Auto = 1,
    Hidden = 2,
    Visible = 3
}
export interface ScrollEvent {
    inSmoothScrolling: boolean;
    oldWidth: number;
    oldScrollWidth: number;
    oldScrollLeft: number;
    width: number;
    scrollWidth: number;
    scrollLeft: number;
    oldHeight: number;
    oldScrollHeight: number;
    oldScrollTop: number;
    height: number;
    scrollHeight: number;
    scrollTop: number;
    widthChanged: boolean;
    scrollWidthChanged: boolean;
    scrollLeftChanged: boolean;
    heightChanged: boolean;
    scrollHeightChanged: boolean;
    scrollTopChanged: boolean;
}
export declare class ScrollState implements IScrollDimensions, IScrollPosition {
    private readonly _forceIntegerValues;
    _scrollStateBrand: void;
    readonly rawScrollLeft: number;
    readonly rawScrollTop: number;
    readonly width: number;
    readonly scrollWidth: number;
    readonly scrollLeft: number;
    readonly height: number;
    readonly scrollHeight: number;
    readonly scrollTop: number;
    constructor(_forceIntegerValues: boolean, width: number, scrollWidth: number, scrollLeft: number, height: number, scrollHeight: number, scrollTop: number);
    equals(other: ScrollState): boolean;
    withScrollDimensions(update: INewScrollDimensions, useRawScrollPositions: boolean): ScrollState;
    withScrollPosition(update: INewScrollPosition): ScrollState;
    createScrollEvent(previous: ScrollState, inSmoothScrolling: boolean): ScrollEvent;
}
export interface IScrollDimensions {
    readonly width: number;
    readonly scrollWidth: number;
    readonly height: number;
    readonly scrollHeight: number;
}
export interface INewScrollDimensions {
    width?: number;
    scrollWidth?: number;
    height?: number;
    scrollHeight?: number;
}
export interface IScrollPosition {
    readonly scrollLeft: number;
    readonly scrollTop: number;
}
export interface ISmoothScrollPosition {
    readonly scrollLeft: number;
    readonly scrollTop: number;
    readonly width: number;
    readonly height: number;
}
export interface INewScrollPosition {
    scrollLeft?: number;
    scrollTop?: number;
}
export interface IScrollableOptions {
    /**
     * Define if the scroll values should always be integers.
     */
    forceIntegerValues: boolean;
    /**
     * Set the duration (ms) used for smooth scroll animations.
     */
    smoothScrollDuration: number;
    /**
     * A function to schedule an update at the next frame (used for smooth scroll animations).
     */
    scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable;
}
export declare class Scrollable extends Disposable {
    _scrollableBrand: void;
    private _smoothScrollDuration;
    private readonly _scheduleAtNextAnimationFrame;
    private _state;
    private _smoothScrolling;
    private _onScroll;
    readonly onScroll: Event<ScrollEvent>;
    constructor(options: IScrollableOptions);
    dispose(): void;
    setSmoothScrollDuration(smoothScrollDuration: number): void;
    validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition;
    getScrollDimensions(): IScrollDimensions;
    setScrollDimensions(dimensions: INewScrollDimensions, useRawScrollPositions: boolean): void;
    /**
     * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
     * If no scroll animation is occurring, it will return the current scroll position instead.
     */
    getFutureScrollPosition(): IScrollPosition;
    /**
     * Returns the current scroll position.
     * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
     */
    getCurrentScrollPosition(): IScrollPosition;
    setScrollPositionNow(update: INewScrollPosition): void;
    setScrollPositionSmooth(update: INewScrollPosition, reuseAnimation?: boolean): void;
    private _performSmoothScrolling;
    private _setState;
}
export declare class SmoothScrollingUpdate {
    readonly scrollLeft: number;
    readonly scrollTop: number;
    readonly isDone: boolean;
    constructor(scrollLeft: number, scrollTop: number, isDone: boolean);
}
export interface IAnimation {
    (completion: number): number;
}
export declare class SmoothScrollingOperation {
    readonly from: ISmoothScrollPosition;
    to: ISmoothScrollPosition;
    readonly duration: number;
    readonly startTime: number;
    animationFrameDisposable: IDisposable | null;
    private scrollLeft;
    private scrollTop;
    constructor(from: ISmoothScrollPosition, to: ISmoothScrollPosition, startTime: number, duration: number);
    private _initAnimations;
    private _initAnimation;
    dispose(): void;
    acceptScrollDimensions(state: ScrollState): void;
    tick(): SmoothScrollingUpdate;
    protected _tick(now: number): SmoothScrollingUpdate;
    combine(from: ISmoothScrollPosition, to: ISmoothScrollPosition, duration: number): SmoothScrollingOperation;
    static start(from: ISmoothScrollPosition, to: ISmoothScrollPosition, duration: number): SmoothScrollingOperation;
}
//# sourceMappingURL=scrollable.d.ts.map