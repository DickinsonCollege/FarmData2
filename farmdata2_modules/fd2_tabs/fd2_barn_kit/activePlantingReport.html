<body>

    <div id="plantingReport" v-cloak>
        <h1 class="text-center">Active Planting Report</h1> <!-- Below are the basic functionalities; just the button, once the button is clicked, API call is made and the static report will be generated -->

        <fieldset :disabled="rowBeingEdited" class="panel panel-default center-block" style="width: 50%;">
            <legend class="panel-heading" style="background-color: #d62a17; color: white;">Click the Button to Generate report</legend>
            <div style="display: flex;width: 100%; padding: 7px"> 
                <button data-cy="generate-rpt-btn" class="btn center-block btn-primary" v-if='!reportVisible' @click='plantingLogRequest'>Generate Report</button>
            </div>
        </fieldset>

        <div v-if='reportVisible'>

           
        </div>
    <script>

        var plantingReport = new Vue ({
            el: '#plantingReport',


            components: {

            },
            data: {
                stillLoading: true,
                reportVisible: false,
                plangintLogs: [],
                updateLog: [],

                sessionToken: null,
                selectedCrop: 'All', // selected are needed for dropdown/date range in the future
                selectedArea: 'All',
                selectedPlanting: 'All',

                headers: [], // these are the headers for the columns
                visibleColumns: [], // use boolean values [true,true,false]

                idToCropMap: new Map(), // these are the mapped IDs to the JSON objects; created once the button is clicked
                cropToIDMap: new Map(),
                idToUserMap: new Map(),
                userToIDMap: new Map(),
                areaToIDMap: new Map(),
                unitToIDMap: new Map(),

                rowBeingEdited: false // this boolean value changes when the user tries to actively edit the rows 
            },
            methods: {
                hide(){
                    this.reportVisible = false // This funciton will be called when length of report = 0 
                    this.plantingLogs = []
                },
                
                },
                plantingLogRequest(){
                    this.reportVisible = true // this value changes when button is clicked
                    let link = '/farm_asset.json?type=planting'   // need to make the API call to the Active Farm report

                    getAllPages(link, this.plantingLogs).then(() => {
                        this.stillLoading = false
                    })
                    this.stillLoading = true
                },


                plantingChange(selectedPlanting){ // bind this to dropdown that selects type of seedings; do we really want this though?
                    this.selectedPlanting = selectedPlanting
                    if(selectedPlanting == 'All'){
                        this.visibleColumns = [true, true, true, true, false, false, false, false, false, false, true, true, true, true, true]
                    }
                    else if(selectedPlanting == 'Direct Seedings'){
                        this.visibleColumns = [true, true, true, true, true, true, true, false, false, false, true, true, true, true, true]
                    }
                    else if(selectedPlanting == 'Tray Seedings'){
                        this.visibleColumns = [true, true, true, true,false, false, false, true, true, true,  true, true, true, true, true]
                    }
                },
                /**
                 * updates the log that the user saved
                 */
                updateRow(updateObject, id){
                    this.updateLog = this.plantingLogs.filter((x) => x.id === id)
                    let updatePlantingObject = {}
                    
                   
                    /**
                     * The Table component returns an object with the cells that were updated. We don't know how many or wich ones where updated, so we check for all possible cells that could have been updated.
                     */
                    let keys = Object.keys(updateObject) // This has to be fixed with the correct keys or columns we include
                    if(keys.includes('Hours') || keys.includes('Num Workers') || 
                        keys.includes('Row/Bed') || keys.includes('Row Feet') ||
                        keys.includes('Tray Seeds') || keys.includes('# of Trays') ||
                        keys.includes('Cells Per Tray')){
                        if(this.updateLog[0].log_category[0].name == 'Direct Seedings'){
                            updatePlantingObject['quantity'] = this.quantityDirectSeeding
                        }
                        else{
                            updatePlantingObject['quantity'] = this.quantityTraySeeding
                        }
                    }
                    
                    for(i=0; i < keys.length; i++){
                        if(keys[i] == 'date'){
                            updatePlantingObject['timestamp'] = dayjs(updateObject['date'], 'YYYY-MM-DD').unix()
                        }
                        else if(keys[i] == 'crop'){
                            updatePlantingObject['data'] = {"crop_tid": this.cropToIDMap.get(updateObject['crop'])}
                            updatePlantObject['crop'] = [{
                                "id": this.cropToIDMap.get(updateObject['crop']),
                                "resource": "taxonomy_term"
                            }]
                        }
                        else if (keys[i] == 'area'){
                            updatePlantingObject['movement'] = { 'area': [{
                                "id": this.areaToIDMap.get(updateObject['area']),
                                "resource": "taxonomy_term",}]
                            }
                        }
                        else if(keys[i] == 'Hours'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Labor')].value = updateObject['Hours']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Labor')].value = updateObject['Hours']
                        }
                        else if(keys[i] == 'Num Workers'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Workers')].value = updateObject['Num Workers']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Workers')].value = updateObject['Num Workers']
                        }
                        else if(keys[i] == 'Comments'){
                            updatePlantingObject['notes'] = {'value': updateObject['Comments'],
                                'format': 'farm_format'}
                        }
                        else if(keys[i] == 'User'){
                            updatePlantingObject['uid'] = {
                                'id': this.userToIDMap.get(updateObject['User']),
                                'resource': 'user'
                            }
                            updatePlantObject['uid'] = {
                                'id': this.userToIDMap.get(updateObject['User']),
                                'resource': 'user'
                            }
                        }
                        else if(keys[i] == 'Row/Bed'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Rows/Bed')].value = updateObject['Row/Bed']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Rows/Bed')].value = updateObject['Row/Bed']
                        }
                        else if(keys[i] == 'Row Feet'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Amount planted')].value = updateObject['Row Feet']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Amount planted')].value = updateObject['Row Feet']
                        }
                        else if(keys[i] == 'Tray Seeds'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Seeds planted')].value = updateObject['Tray Seeds']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Seeds planted')].value = updateObject['Tray Seeds']
                        }
                        else if(keys[i] == '# of Trays'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Flats used')].value = updateObject['# of Trays']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Flats used')].value = updateObject['# of Trays']
                        }
                        else if(keys[i] == 'Cells Per Tray'){
                            updatePlantingObject.quantity[quantityLocation(updatePlantingObject.quantity, 'Cells/Flat')].value = updateObject['Cells Per Tray']

                            this.updateLog[0].quantity[quantityLocation(this.updateLog[0].quantity, 'Cells/Flat')].value = updateObject['Cells Per Tray']
                        }   
                    }
                    //replace old update log with current update log needs to be fixed with correct keys or columns
                    if(keys.includes('Hours') || keys.includes('Num Workers') || 
                        keys.includes('Row/Bed') || keys.includes('Row Feet') ||
                        keys.includes('Tray Seeds') || keys.includes('# of Trays') ||
                        keys.includes('Cells Per Tray')){
                        for(var i=0; i < this.plantingLogs.length; i++){
                            if(this.plantingLogs[i].id === id){
                                this.plantingLogs.splice(i, this.updateLog)
                            }
                        }    
                    }
                    
                    let plantingUrl = '/farm_asset/' + this.updateLog[0].asset[0].id
                    //call updateRecord function to update planting log
                    if(!(Object.entries(updatePlantObject).length === 0)){
                        updateRecord(plantingUrl, updatePlantObject, this.sessionToken)
                    }
                    //call updateRecord function to update seeding log
                    if(!(Object.entries(updatePlantingObject).length === 0)){
                        updateRecord(seedingUrl, updatePlantingObject,this.sessionToken)
                    }
                    this.rowBeingEdited = false
                },
                /**
                 * Uses deleteRecord function to delete the record in the database. Also deletes the record from the current logs that are in plantingLogs
                 */
                deleteRowLog(logID) {
                    let url = '/log/' + logID
                    deleteRecord(url, this.sessionToken)
                    for(var i=0; i < this.plantingLogs.length; i++){
                        if(this.plantingLogs[i].id === logID){
                            this.plantingLogs.splice(i, 1)
                        }
                    }
                },
                disableFilters() {
                    this.rowBeingEdited = true
                },
                enableFilters(){
                    this.rowBeingEdited = false
                },
            },
            computed: {
                /**
                 * tableRows() filters though plantingLogs to get all the logs that have the correct crop, area, and/or type of seeding that has been selected by the user. Then takes the remaining logs and formats it so that the table component gets the necessary info
                 * This whole thing has to be fixed to include the objects that we want for the report
                 * Need to look at the JSON file to decide what to include
                 */ 
                tableRows() {
                    let filterRows = this.plantingLogs.filter((x) => x)

                    if(this.selectedArea != 'All'){
                        filterRows = filterRows.filter((x) => x.movement.area[0].name === this.selectedArea)
                    }
                    if(this.selectedCrop != 'All'){
                        filterRows = filterRows.filter((x) => this.idToCropMap.get(x.data.crop_tid) === this.selectedCrop)
                    }
                    if(this.selectedSeeding != 'All'){
                        filterRows = filterRows.filter((x) => x.log_category[0].name === this.selectedSeeding)
                    }
                    let $vm = this
                    let rows = filterRows.map(function(h) {
                        let rowBed = 0
                        let rowFeet = 0
                        let bedFeet = 0
                        let traySeeds = 0
                        let numOfTrays = 0
                        let cellsPerTray = 0
                        let hours = 0
                        let numWorkers = 0
                        if(h.log_category[0].name === 'Direct Seedings'){
                            rowBed = h.quantity[1].value
                            rowFeet = h.quantity[0].value
                            bedFeet = rowFeet/rowBed
                            hours = h.quantity[2].value
                            numWorkers = h.quantity[3].value
                        }
                        else{
                            traySeeds = h.quantity[0].value
                            numOfTrays = h.quantity[1].value
                            cellsPerTray = h.quantity[2].value
                            hours = h.quantity[3].value
                            numWorkers = h.quantity[4].value
                        }
                        return{
                            id: h.id,
                            data: [
                                dayjs.unix(h.timestamp).format('YYYY-MM-DD'),
                                $vm.idToCropMap.get(h.data.crop_tid),
                                h.movement.area[0].name, 
                                h.log_category[0].name, 
                                rowBed,
                                rowFeet,
                                bedFeet,
                                traySeeds,
                                numOfTrays,
                                cellsPerTray,
                                (Math.round(hours*100))/100,
                                (Math.round(numWorkers*100))/100,
                                h.lot_number,
                                h.notes.value,
                                $vm.idToUserMap.get(h.uid.id)
                            ]
                        }
                    })
                    return rows
                },
                getTableOneType(){ // This has to be fixed to fit the data as well
                    let currentType = this.tableRows[0].data[3]
                    for (i = 0 ; i < this.tableRows.length ; i ++){
                        if (this.tableRows[i].data[3] == currentType){
                            currentType = this.tableRows[i].data[3]
                        }else{
                            return false
                        }
                    }
                    return currentType
                },
                /**
                 * returns a sorted array of all the crops in the current logs. If area or type of seeding does not equal 'All' then the array will only contain crops that have the selected area and/or type of seeding
                 * The way that the planting asset JSON saves this is different from seeding report needds to be fixed
                 */ 
                cropList(){
                    let seedFilter = []
                    if(this.selectedSeeding != 'All'){
                        seedFilter = this.plantingLogs.filter((x) => x.log_category[0].name === this.selectedSeeding)
                    }
                    else{
                        seedFilter = this.plantingLogs.filter((x) => x)
                    }
                    let cropArray = []
                    if(this.selectedArea != 'All'){
                        let areaFilter = seedFilter.filter((x) => x.movement.area[0].name === this.selectedArea)
                        cropArray = areaFilter.map(h => 
                            this.idToCropMap.get(h.data.crop_tid)
                        )
                    }
                    else{
                        cropArray = seedFilter.map(h=> 
                            this.idToCropMap.get(h.data.crop_tid)
                        )
                    }

                    let crops = new Set(cropArray)
                    let newCropArray = Array.from(crops)
                    return newCropArray.sort()
                },
                /**
                 * returns a sorted array of all the areas in the current logs. If a crop or type of seeding does not equal 'All' then the array will only contain areas that have the selected crop and/or type of seeding
                 * Has to be fixed as well. We probably need this, so need to find a way to make it work with Planting asset JSON
                 */ 
                areaList(){
                    let seedFilter = []
                    if(this.selectedSeeding != 'All'){
                        seedFilter = this.plantingLogs.filter((x) => x.log_category[0].name === this.selectedSeeding)
                    }
                    else{
                        seedFilter = this.plantingLogs.filter((x) => x)
                    }
                    let areaArray = []
                    if(this.selectedCrop != 'All'){
                        let cropFilter = seedFilter.filter((x) => this.idToCropMap.get(x.data.crop_tid) === this.selectedCrop)
                         areaArray = cropFilter.map(h =>
                            h.movement.area[0].name
                        )
                    }
                    else{
                        areaArray = seedFilter.map(h =>
                            h.movement.area[0].name
                        )
                    }
                    let areas = new Set(areaArray)
                    let newAreaArray = Array.from(areas)
                    return newAreaArray.sort()
                },
                /**
                 * returns a sorted array of all the types of seeding in the current logs. If the area or crop does not equal 'All' then the array will only contain types of seeding that have the selected area and/or crop
                 * Same here we need this for the report, so need to find away to fix
                 */ 
                seedingTypeList(){
                    let areaFilter = []
                    if(this.selectedArea != 'All'){
                        areaFilter = this.plantingLogs.filter((x) => x.movement.area[0].name === this.selectedArea)
                    }
                    else{
                        areaFilter = this.plantingLogs.filter((x) => x)
                    }
                    let seedingTypeArray = []
                    if(this.selectedCrop != 'All'){
                        let cropFilter = areaFilter.filter((x) => this.idToCropMap.get(x.data.crop_tid) === this.selectedCrop)
                        seedingTypeArray = cropFilter.map(h =>
                            h.log_category[0].name
                        )
                    }
                    else{
                        seedingTypeArray = areaFilter.map(h => 
                            h.log_category[0].name
                        )
                    }
                    let seedingsType = new Set(seedingTypeArray)
                    let newSeedingTypeArray = Array.from(seedingsType)
                    return newSeedingTypeArray.sort()
                },
                /**
                 * returns the total row/bed for the Direct Seedings
                 * We probalby do not need this but will not delete just in case. 
                 */ 
                totalRowBed(){
                    let tableData = this.tableRows
                    
                    let sumRowBed = 0
                    tableData.map(h => {
                        sumRowBed = sumRowBed + parseInt(h.data[4])
                    })

                    return sumRowBed
                },
                /**
                 * returns the total row feet for Direct Seeding
                 * We probalby do not need this but will not delete just in case.  
                 */ 
                totalRowFeet(){
                    let tableData = this.tableRows
                    let sumRowFeet = 0
                    tableData.map(h => {
                        sumRowFeet = sumRowFeet + parseInt(h.data[5])
                    })
                    return (Math.round(sumRowFeet*100))/100
                },
                /**
                 * returns the total bed feet for Direct Seeding
                 * We probalby do not need this but will not delete just in case. 
                 */ 
                totalBedFeet(){
                    let tableData = this.tableRows
                    let sumBedFeet = 0
                    tableData.map(h => {
                        sumBedFeet = sumBedFeet + parseInt(h.data[6])
                    })
                    return sumBedFeet
                },
               
              
                /**
                 * returns the total number of seeds planted for the tray seeding logs
                 * We probalby do not need this but will not delete just in case. 
                 */ 
                traySeedsPlanted(){
                    let tableData = this.tableRows
                    let totalTraySeeds = 0
                    tableData.map(h =>
                       totalTraySeeds = totalTraySeeds + parseFloat(h.data[7])
                    )
                    return totalTraySeeds
                },
                /**
                 * returns the total number of trays(flats) for the Tray Seedings logs
                 * We probalby do not need this but will not delete just in case. 
                 */ 
                totalNumTrays(){
                    let tableData = this.tableRows
                    let totalTrays = 0
                    tableData.map(h =>
                       totalTrays = totalTrays + parseFloat(h.data[8])
                    )
                    return (Math.round(totalTrays*100))/100
                },
              
               
                /**
                 * returns the structure for updating the quantity section of the Direct Seeding Logs. The values have not been updated yet.
                 * We might need this if we want to make the table active, unlikely for the demo.
                 */
                quantityDirectSeeding(){
                    return [
                        {
                            "measure": "length", 
                            "value": this.updateLog[0].quantity[0].value,
                            "unit": {
                                "id": this.unitToIDMap.get('ROW FEET'), 
                                "resource": "taxonomy_term"
                            },
                            "label": "Amount planted"
                        },
                        {
                            "measure": "ratio", 
                            "value": this.updateLog[0].quantity[1].value,
                            "unit": {
                                "id": this.unitToIDMap.get('ROWS/BED'),
                                "resource": "taxonomy_term"
                            },
                            "label": "Rows/Bed"
                        },
                        {
                            "measure": "time", 
                            "value": this.updateLog[0].quantity[2].value,
                            "unit": {
                                "id": this.unitToIDMap.get('HOURS'),
                                "resource": "taxonomy_term"
                            },
                            "label": "Labor"
                        },
                        {
                            "measure": "count", 
                            "value": this.updateLog[0].quantity[3].value,
                            "unit": {
                                "id": this.unitToIDMap.get('PEOPLE'),
                                "resource": "taxonomy_term"
                            },
                            "label": "Workers"
                        },
                    ]
                },
                /**
                 * returns the structure for updating the quantity section of the Tray Seeding Logs. The values have not been updated yet.
                 * We might need this if we want to make the table active, unlikely for the demo.
                 */
                quantityTraySeeding(){
                    return [
                        {
                            "measure": "count", 
                            "value": this.updateLog[0].quantity[0].value,
                            "unit": {
                                "id": this.unitToIDMap.get('SEEDS'), 
                                "resource": "taxonomy_term"
                            },
                            "label": "Seeds planted"
                        },
                        {
                            "measure": "count", 
                            "value": this.updateLog[0].quantity[1].value,
                            "unit": {
                                "id": this.unitToIDMap.get('FLATS'), 
                                "resource": "taxonomy_term"
                            },
                            "label": "Flats used" //also known as trays used
                        },
                        {
                            "measure": "ratio", 
                            "value": this.updateLog[0].quantity[2].value,
                            "unit": {
                                "id": this.unitToIDMap.get('CELLS/FLAT'),
                                "resource": "taxonomy_term"
                            },
                            "label": "Cells/Flat"
                        },
                        {
                            "measure": "time", 
                            "value": this.updateLog[0].quantity[3].value,
                            "unit": {
                                "id": this.unitToIDMap.get('HOURS'),
                                "resource": "taxonomy_term"
                            },
                            "label": "Labor"
                        },
                        {
                            "measure": "count", 
                            "value": this.updateLog[0].quantity[4].value,
                            "unit": {
                                "id": this.unitToIDMap.get('PEOPLE'),
                                "resource": "taxonomy_term"
                            },
                            "label": "Workers"
                        },
                    ]
                },
                /**
                 * returns the input options for each column in the table. Uses the maps in created to get the all crops, areas, and users in the database, in order to create respective dropdowns.
                 * We might need this if we want to make the table active, unlikely for the demo.
                 */ 
                columnInputs(){
                    let userNameArray = []
                    const userKeyIterator = this.userToIDMap.keys()
                    for(i=0; i < this.userToIDMap.size; i++){
                        userNameArray.push(userKeyIterator.next().value)
                    }
                    let cropNameArray = []
                    for(let [key, info] of this.cropToIDMap){
                        cropNameArray.push(key)
                    }
                    let areaNameArray = []
                    const areaKeyIterator = this.areaToIDMap.keys()
                    for(i=0; i < this.areaToIDMap.size; i++){
                        areaNameArray.push(areaKeyIterator.next().value)
                    }
                    return [{type:'date'}, {type:'dropdown', value: cropNameArray}, {type:'dropdown', value: areaNameArray}, {type:'no input'}, {type:'number'}, {type:'number'}, {type:'no input'}, {type:'number'}, {type:'number'}, {type:'number'}, {type:'number'}, {type:'number'}, {type:'no input'}, {type:'text'}, {type:'dropdown', value: userNameArray}]
                }
            },
            created() { //These maps must be fixed as they might not be included in the Planting Asset Json
                getSessionToken().then((response) => {
                    this.sessionToken = response
                })
                getIDToCropMap().then((response) => {
                    this.idToCropMap = new Map(response)
                })
                getCropToIDMap().then((response) => {
                    this.cropToIDMap = new Map(response)
                })
                getIDToUserMap().then((response) => {
                    this.idToUserMap = new Map (response)
                })
                getUserToIDMap().then((response) => {
                    this.userToIDMap = new Map (response)
                })
                getAreaToIDMap().then((response) => {
                    this.areaToIDMap = new Map(response)
                })
                getUnitToIDMap().then((response) => {
                    this.unitToIDMap = new Map(response)
                })
            }
        });
        Vue.config.devtools = true;
    </script>
</body>